[
  {
    "cate": "prometheus",
    "datasource_queries": [
      {
        "match_type": 2,
        "op": "in",
        "values": []
      }
    ],
    "name": "KubernetesContainerCPUPressure",
    "note": "Pod {{ $labels.pod }} Container {{ $labels.container }} in Namespace {{ $labels.namespace }} has cpu pressure.",
    "prod": "metric",
    "delay": 0,
    "prom_for_duration": 600,
    "rule_config": {
      "inhibit": true,
      "queries": [
        {
          "prom_ql": "sum(rate(container_cpu_usage_seconds_total{image!~\".*pause.*\",container!=\"\"}[2m])) by (pod,namespace,container) / max (kube_pod_container_resource_limits{image!~\".*pause.*\",container!=\"\",resource=\"cpu\"}) by (pod,namespace,container) * 100 > 75",
          "recover_config": {
            "judge_type": 0,
            "recover_exp": ""
          },
          "severity": 3,
          "unit": "",
          "var_config": {
            "child_var_configs": null,
            "param_val": null
          },
          "var_enabled": false
        },
        {
          "prom_ql": "sum(rate(container_cpu_usage_seconds_total{image!~\".*pause.*\",container!=\"\"}[2m])) by (pod,namespace,container) / max (kube_pod_container_resource_limits{image!~\".*pause.*\",container!=\"\",resource=\"cpu\"}) by (pod,namespace,container) * 100 > 85",
          "severity": 2
        },
        {
          "prom_ql": "sum(rate(container_cpu_usage_seconds_total{image!~\".*pause.*\",container!=\"\"}[2m])) by (pod,namespace,container) / max (kube_pod_container_resource_limits{image!~\".*pause.*\",container!=\"\",resource=\"cpu\"}) by (pod,namespace,container) * 100 > 95",
          "severity": 1
        }
      ]
    },
    "event_relabel_config": null,
    "prom_eval_interval": 15,
    "enable_in_bg": 1,
    "notify_recovered": 1,
    "notify_repeat_step": 60,
    "notify_max_number": 0,
    "recover_duration": 0,
    "callbacks": [],
    "append_tags": [],
    "annotations": {},
    "uuid": 0,
    "cur_event_count": 0,
    "update_by_nickname": "long",
    "cron_pattern": "@every 60s",
    "notify_rule_ids": [
      1
    ],
    "notify_version": 1
  },
  {
    "cate": "prometheus",
    "datasource_queries": [
      {
        "match_type": 2,
        "op": "in",
        "values": []
      }
    ],
    "name": "KubernetesContainerMemoryPressure",
    "note": "Pod {{ $labels.pod }} Container {{ $labels.container }} in Namespace {{ $labels.namespace }} has memory pressure.",
    "prod": "metric",
    "delay": 0,
    "prom_for_duration": 600,
    "rule_config": {
      "inhibit": true,
      "queries": [
        {
          "prom_ql": "sum(container_memory_usage_bytes{image!~\".*pause.*\",container!~\"|memcached\",namespace!=\"kube-system\"}) by (pod,namespace,container) / max (kube_pod_container_resource_limits{image!~\".*pause.*\",container!~\"|memcached\",resource=\"memory\",namespace!=\"kube-system\"}) by (pod,namespace,container) * 100 > 75",
          "recover_config": {
            "judge_type": 0,
            "recover_exp": ""
          },
          "severity": 3,
          "unit": "",
          "var_config": {
            "child_var_configs": null,
            "param_val": null
          },
          "var_enabled": false
        },
        {
          "prom_ql": "sum(container_memory_usage_bytes{image!~\".*pause.*\",container!~\"|memcached\",namespace!=\"kube-system\"}) by (pod,namespace,container) / max (kube_pod_container_resource_limits{image!~\".*pause.*\",container!~\"|memcached\",resource=\"memory\",namespace!=\"kube-system\"}) by (pod,namespace,container) * 100 > 85",
          "severity": 2
        },
        {
          "prom_ql": "sum(container_memory_usage_bytes{image!~\".*pause.*\",container!~\"|memcached\",namespace!=\"kube-system\"}) by (pod,namespace,container) / max (kube_pod_container_resource_limits{image!~\".*pause.*\",container!~\"|memcached\",resource=\"memory\",namespace!=\"kube-system\"}) by (pod,namespace,container) * 100 > 95",
          "severity": 1
        }
      ]
    },
    "event_relabel_config": null,
    "prom_eval_interval": 15,
    "enable_in_bg": 1,
    "notify_recovered": 1,
    "notify_repeat_step": 60,
    "notify_max_number": 0,
    "recover_duration": 0,
    "callbacks": [],
    "append_tags": [],
    "annotations": {},
    "uuid": 0,
    "cur_event_count": 0,
    "update_by_nickname": "long",
    "cron_pattern": "@every 60s",
    "notify_rule_ids": [
      1
    ],
    "notify_version": 1
  },
  {
    "cate": "prometheus",
    "datasource_queries": [
      {
        "match_type": 2,
        "op": "in",
        "values": []
      }
    ],
    "name": "KubernetesContainerOomKiller",
    "note": "Pod {{ $labels.pod }} Container {{ $labels.container }} in Namespace {{ $labels.namespace }} has oom.",
    "prod": "metric",
    "delay": 0,
    "prom_for_duration": 60,
    "rule_config": {
      "inhibit": false,
      "queries": [
        {
          "prom_ql": "(kube_pod_container_status_restarts_total - kube_pod_container_status_restarts_total offset 10m >= 1) and ignoring (reason) min_over_time(kube_pod_container_status_last_terminated_reason{reason=\"OOMKilled\"}[10m]) == 1",
          "recover_config": {
            "judge_type": 0,
            "recover_exp": ""
          },
          "severity": 2,
          "unit": "",
          "var_config": {
            "child_var_configs": null,
            "param_val": null
          },
          "var_enabled": false
        }
      ]
    },
    "event_relabel_config": null,
    "prom_eval_interval": 15,
    "enable_in_bg": 1,
    "notify_recovered": 1,
    "notify_repeat_step": 60,
    "notify_max_number": 0,
    "recover_duration": 0,
    "callbacks": [],
    "append_tags": [],
    "annotations": {
      "description": "Container {{ $labels.container }} in pod {{ $labels.namespace }}/{{ $labels.pod }} has been OOMKilled {{ $value }} times in the last 10 minutes.\n  VALUE = {{ $value }}\n  LABELS = {{ $labels }}",
      "summary": "Kubernetes container oom killer ({{ $labels.namespace }}/{{ $labels.pod }}:{{ $labels.container }})"
    },
    "uuid": 0,
    "cur_event_count": 0,
    "update_by_nickname": "long",
    "cron_pattern": "@every 60s",
    "notify_rule_ids": [
      1
    ],
    "notify_version": 1
  },
  {
    "cate": "prometheus",
    "datasource_queries": [
      {
        "match_type": 2,
        "op": "in",
        "values": []
      }
    ],
    "name": "KubernetesDeploymentGenerationMismatch",
    "note": "",
    "prod": "metric",
    "delay": 0,
    "prom_for_duration": 600,
    "rule_config": {
      "algo_params": null,
      "inhibit": false,
      "prom_ql": "",
      "queries": [
        {
          "prom_ql": "kube_deployment_status_observed_generation != kube_deployment_metadata_generation",
          "recover_config": {
            "judge_type": 0,
            "recover_exp": ""
          },
          "severity": 1,
          "unit": "",
          "var_config": {
            "child_var_configs": null,
            "param_val": null
          },
          "var_enabled": false
        }
      ],
      "severity": 0
    },
    "event_relabel_config": null,
    "prom_eval_interval": 15,
    "enable_in_bg": 1,
    "notify_recovered": 1,
    "notify_repeat_step": 60,
    "notify_max_number": 0,
    "recover_duration": 0,
    "callbacks": [],
    "append_tags": [],
    "annotations": {
      "description": "Deployment {{ $labels.namespace }}/{{ $labels.deployment }} has failed but has not been rolled back.\n  VALUE = {{ $value }}\n  LABELS = {{ $labels }}",
      "summary": "Kubernetes Deployment generation mismatch ({{ $labels.namespace }}/{{ $labels.deployment }})"
    },
    "uuid": 0,
    "cur_event_count": 0,
    "update_by_nickname": "long",
    "cron_pattern": "@every 60s",
    "notify_rule_ids": [
      1
    ],
    "notify_version": 1
  },
  {
    "cate": "prometheus",
    "datasource_queries": [
      {
        "match_type": 2,
        "op": "in",
        "values": []
      }
    ],
    "name": "KubernetesDeploymentReplicasMismatch",
    "note": "",
    "prod": "metric",
    "delay": 0,
    "prom_for_duration": 600,
    "rule_config": {
      "algo_params": null,
      "inhibit": false,
      "prom_ql": "",
      "queries": [
        {
          "prom_ql": "kube_deployment_spec_replicas != kube_deployment_status_replicas_available",
          "recover_config": {
            "judge_type": 0,
            "recover_exp": ""
          },
          "severity": 2,
          "unit": "",
          "var_config": {
            "child_var_configs": null,
            "param_val": null
          },
          "var_enabled": false
        }
      ],
      "severity": 0
    },
    "event_relabel_config": null,
    "prom_eval_interval": 15,
    "enable_in_bg": 1,
    "notify_recovered": 1,
    "notify_repeat_step": 60,
    "notify_max_number": 0,
    "recover_duration": 0,
    "callbacks": [],
    "append_tags": [],
    "annotations": {
      "description": "Deployment {{ $labels.namespace }}/{{ $labels.deployment }} replicas mismatch\n  VALUE = {{ $value }}\n  LABELS = {{ $labels }}",
      "summary": "Kubernetes Deployment replicas mismatch ({{ $labels.namespace }}/{{ $labels.deployment }})"
    },
    "uuid": 0,
    "cur_event_count": 0,
    "update_by_nickname": "long",
    "cron_pattern": "@every 60s",
    "notify_rule_ids": [
      1
    ],
    "notify_version": 1
  },
  {
    "cate": "prometheus",
    "datasource_queries": [
      {
        "match_type": 2,
        "op": "in",
        "values": []
      }
    ],
    "name": "KubernetesHpaMetricsUnavailability",
    "note": "",
    "prod": "metric",
    "delay": 0,
    "prom_for_duration": 60,
    "rule_config": {
      "algo_params": null,
      "inhibit": false,
      "prom_ql": "",
      "queries": [
        {
          "prom_ql": "kube_horizontalpodautoscaler_status_condition{status=\"false\", condition=\"ScalingActive\"} == 1",
          "recover_config": {
            "judge_type": 0,
            "recover_exp": ""
          },
          "severity": 2,
          "unit": "",
          "var_config": {
            "child_var_configs": null,
            "param_val": null
          },
          "var_enabled": false
        }
      ],
      "severity": 0
    },
    "event_relabel_config": null,
    "prom_eval_interval": 15,
    "enable_in_bg": 1,
    "notify_recovered": 1,
    "notify_repeat_step": 60,
    "notify_max_number": 0,
    "recover_duration": 0,
    "callbacks": [],
    "append_tags": [],
    "annotations": {
      "description": "HPA {{ $labels.namespace }}/{{ $labels.horizontalpodautoscaler }} is unable to collect metrics\n  VALUE = {{ $value }}\n  LABELS = {{ $labels }}",
      "summary": "Kubernetes HPA metrics unavailability (instance {{ $labels.instance }})"
    },
    "uuid": 0,
    "cur_event_count": 0,
    "update_by_nickname": "long",
    "cron_pattern": "@every 60s",
    "notify_rule_ids": [
      1
    ],
    "notify_version": 1
  },
  {
    "cate": "prometheus",
    "datasource_queries": [
      {
        "match_type": 2,
        "op": "in",
        "values": []
      }
    ],
    "name": "KubernetesHpaScaleInability",
    "note": "",
    "prod": "metric",
    "delay": 0,
    "prom_for_duration": 120,
    "rule_config": {
      "algo_params": null,
      "inhibit": false,
      "prom_ql": "",
      "queries": [
        {
          "prom_ql": "(kube_horizontalpodautoscaler_spec_max_replicas - kube_horizontalpodautoscaler_status_desired_replicas) * on (horizontalpodautoscaler,namespace) (kube_horizontalpodautoscaler_status_condition{condition=\"ScalingLimited\", status=\"true\"} == 1) == 0",
          "recover_config": {
            "judge_type": 0,
            "recover_exp": ""
          },
          "severity": 2,
          "unit": "",
          "var_config": {
            "child_var_configs": null,
            "param_val": null
          },
          "var_enabled": false
        }
      ],
      "severity": 0
    },
    "event_relabel_config": null,
    "prom_eval_interval": 15,
    "enable_in_bg": 1,
    "notify_recovered": 1,
    "notify_repeat_step": 60,
    "notify_max_number": 0,
    "recover_duration": 0,
    "callbacks": [],
    "append_tags": [],
    "annotations": {
      "description": "HPA {{ $labels.namespace }}/{{ $labels.horizontalpodautoscaler }} is unable to scale\n  VALUE = {{ $value }}\n  LABELS = {{ $labels }}",
      "summary": "Kubernetes HPA scale inability (instance {{ $labels.instance }})"
    },
    "uuid": 0,
    "cur_event_count": 0,
    "update_by_nickname": "long",
    "cron_pattern": "@every 60s",
    "notify_rule_ids": [
      1
    ],
    "notify_version": 1
  },
  {
    "cate": "prometheus",
    "datasource_queries": [
      {
        "match_type": 2,
        "op": "in",
        "values": []
      }
    ],
    "name": "KubernetesHpaScaleMaximum",
    "note": "",
    "prod": "metric",
    "delay": 0,
    "prom_for_duration": 120,
    "rule_config": {
      "algo_params": null,
      "inhibit": false,
      "prom_ql": "",
      "queries": [
        {
          "prom_ql": "(kube_horizontalpodautoscaler_status_desired_replicas >= kube_horizontalpodautoscaler_spec_max_replicas) and (kube_horizontalpodautoscaler_spec_max_replicas > 1) and (kube_horizontalpodautoscaler_spec_min_replicas != kube_horizontalpodautoscaler_spec_max_replicas)",
          "recover_config": {
            "judge_type": 0,
            "recover_exp": ""
          },
          "severity": 3,
          "unit": "",
          "var_config": {
            "child_var_configs": null,
            "param_val": null
          },
          "var_enabled": false
        }
      ],
      "severity": 0
    },
    "event_relabel_config": null,
    "prom_eval_interval": 15,
    "enable_in_bg": 1,
    "notify_recovered": 1,
    "notify_repeat_step": 60,
    "notify_max_number": 0,
    "recover_duration": 0,
    "callbacks": [],
    "append_tags": [],
    "annotations": {
      "description": "HPA {{ $labels.namespace }}/{{ $labels.horizontalpodautoscaler }} has hit maximum number of desired pods\n  VALUE = {{ $value }}\n  LABELS = {{ $labels }}",
      "summary": "Kubernetes HPA scale maximum (instance {{ $labels.instance }})"
    },
    "uuid": 0,
    "cur_event_count": 0,
    "update_by_nickname": "long",
    "cron_pattern": "@every 60s",
    "notify_rule_ids": [
      1
    ],
    "notify_version": 1
  },
  {
    "cate": "prometheus",
    "datasource_queries": [
      {
        "match_type": 2,
        "op": "in",
        "values": []
      }
    ],
    "name": "KubernetesHpaUnderutilized",
    "note": "",
    "prod": "metric",
    "delay": 0,
    "prom_for_duration": 60,
    "rule_config": {
      "algo_params": null,
      "inhibit": false,
      "prom_ql": "",
      "queries": [
        {
          "prom_ql": "max(quantile_over_time(0.5, kube_horizontalpodautoscaler_status_desired_replicas[1d]) == kube_horizontalpodautoscaler_spec_min_replicas) by (horizontalpodautoscaler) > 3",
          "recover_config": {
            "judge_type": 0,
            "recover_exp": ""
          },
          "severity": 3,
          "unit": "",
          "var_config": {
            "child_var_configs": null,
            "param_val": null
          },
          "var_enabled": false
        }
      ],
      "severity": 0
    },
    "event_relabel_config": null,
    "prom_eval_interval": 15,
    "enable_in_bg": 1,
    "notify_recovered": 1,
    "notify_repeat_step": 60,
    "notify_max_number": 0,
    "recover_duration": 0,
    "callbacks": [],
    "append_tags": [],
    "annotations": {
      "description": "HPA {{ $labels.namespace }}/{{ $labels.horizontalpodautoscaler }} is constantly at minimum replicas for 50% of the time. Potential cost saving here.\n  VALUE = {{ $value }}\n  LABELS = {{ $labels }}",
      "summary": "Kubernetes HPA underutilized (instance {{ $labels.instance }})"
    },
    "uuid": 0,
    "cur_event_count": 0,
    "update_by_nickname": "long",
    "cron_pattern": "@every 60s",
    "notify_rule_ids": [
      1
    ],
    "notify_version": 1
  },
  {
    "cate": "prometheus",
    "datasource_queries": [
      {
        "match_type": 2,
        "op": "in",
        "values": []
      }
    ],
    "name": "KubernetesNodeDiskPressure",
    "note": "Node {{ $labels.node }} has DiskPressure condition.",
    "prod": "metric",
    "delay": 0,
    "prom_for_duration": 120,
    "rule_config": {
      "inhibit": false,
      "queries": [
        {
          "prom_ql": "kube_node_status_condition{condition=\"DiskPressure\",status=\"true\"} == 1",
          "recover_config": {
            "judge_type": 0,
            "recover_exp": ""
          },
          "severity": 1,
          "unit": "",
          "var_config": {
            "child_var_configs": null,
            "param_val": null
          },
          "var_enabled": false
        }
      ]
    },
    "event_relabel_config": null,
    "prom_eval_interval": 15,
    "enable_in_bg": 1,
    "notify_recovered": 1,
    "notify_repeat_step": 60,
    "notify_max_number": 0,
    "recover_duration": 0,
    "callbacks": [],
    "append_tags": [],
    "annotations": {},
    "uuid": 0,
    "cur_event_count": 0,
    "update_by_nickname": "long",
    "cron_pattern": "@every 60s",
    "notify_rule_ids": [
      1
    ],
    "notify_version": 1
  },
  {
    "cate": "prometheus",
    "datasource_queries": [
      {
        "match_type": 2,
        "op": "in",
        "values": []
      }
    ],
    "name": "KubernetesNodeMemoryPressure",
    "note": "Node {{ $labels.node }} has MemoryPressure condition.",
    "prod": "metric",
    "delay": 0,
    "prom_for_duration": 120,
    "rule_config": {
      "inhibit": false,
      "queries": [
        {
          "prom_ql": "kube_node_status_condition{condition=\"MemoryPressure\",status=\"true\"} == 1",
          "recover_config": {
            "judge_type": 0,
            "recover_exp": ""
          },
          "severity": 1,
          "unit": "",
          "var_config": {
            "child_var_configs": null,
            "param_val": null
          },
          "var_enabled": false
        }
      ]
    },
    "event_relabel_config": null,
    "prom_eval_interval": 15,
    "enable_in_bg": 1,
    "notify_recovered": 1,
    "notify_repeat_step": 60,
    "notify_max_number": 0,
    "recover_duration": 0,
    "callbacks": [],
    "append_tags": [],
    "annotations": {},
    "uuid": 0,
    "cur_event_count": 0,
    "update_by_nickname": "long",
    "cron_pattern": "@every 60s",
    "notify_rule_ids": [
      1
    ],
    "notify_version": 1
  },
  {
    "cate": "prometheus",
    "datasource_queries": [
      {
        "match_type": 2,
        "op": "in",
        "values": []
      }
    ],
    "name": "KubernetesNodeNetworkUnavailable",
    "note": "Node {{ $labels.node }} has network unavailable.",
    "prod": "metric",
    "delay": 0,
    "prom_for_duration": 120,
    "rule_config": {
      "inhibit": false,
      "queries": [
        {
          "prom_ql": "kube_node_status_condition{condition=\"NetworkUnavailable\",status=\"true\"} == 1",
          "recover_config": {
            "judge_type": 0,
            "recover_exp": ""
          },
          "severity": 1,
          "unit": "",
          "var_config": {
            "child_var_configs": null,
            "param_val": null
          },
          "var_enabled": false
        }
      ]
    },
    "event_relabel_config": null,
    "prom_eval_interval": 15,
    "enable_in_bg": 1,
    "notify_recovered": 1,
    "notify_repeat_step": 60,
    "notify_max_number": 0,
    "recover_duration": 0,
    "callbacks": [],
    "append_tags": [],
    "annotations": {
      "description": "Node {{ $labels.node }} has NetworkUnavailable condition\n  VALUE = {{ $value }}\n  LABELS = {{ $labels }}",
      "summary": "Kubernetes Node network unavailable (instance {{ $labels.instance }})"
    },
    "uuid": 0,
    "cur_event_count": 0,
    "update_by_nickname": "long",
    "cron_pattern": "@every 60s",
    "notify_rule_ids": [
      1
    ],
    "notify_version": 1
  },
  {
    "cate": "prometheus",
    "datasource_queries": [
      {
        "match_type": 2,
        "op": "in",
        "values": []
      }
    ],
    "name": "KubernetesNodeNotReady",
    "note": "Node {{ $labels.node }} has been unready for a long time.",
    "prod": "metric",
    "delay": 0,
    "prom_for_duration": 600,
    "rule_config": {
      "inhibit": false,
      "queries": [
        {
          "prom_ql": "kube_node_status_condition{condition=\"Ready\",status=\"true\"} == 0",
          "recover_config": {
            "judge_type": 0,
            "recover_exp": ""
          },
          "severity": 1,
          "unit": "",
          "var_config": {
            "child_var_configs": null,
            "param_val": null
          },
          "var_enabled": false
        }
      ]
    },
    "event_relabel_config": null,
    "prom_eval_interval": 15,
    "enable_in_bg": 1,
    "notify_recovered": 1,
    "notify_repeat_step": 60,
    "notify_max_number": 0,
    "recover_duration": 0,
    "callbacks": [],
    "append_tags": [],
    "annotations": {},
    "uuid": 0,
    "cur_event_count": 0,
    "update_by_nickname": "long",
    "cron_pattern": "@every 60s",
    "notify_rule_ids": [
      1
    ],
    "notify_version": 1
  },
  {
    "cate": "prometheus",
    "datasource_queries": [
      {
        "match_type": 2,
        "op": "in",
        "values": []
      }
    ],
    "name": "KubernetesNodeOutOfPodCapacity",
    "note": "Node {{ $labels.node }} has out of pod capacity.",
    "prod": "metric",
    "delay": 0,
    "prom_for_duration": 120,
    "rule_config": {
      "inhibit": false,
      "queries": [
        {
          "prom_ql": "sum by (node) ((kube_pod_status_phase{phase=\"Running\"} == 1) + on(uid, instance) group_left(node) (0 * kube_pod_info{pod_template_hash=\"\"})) / sum by (node) (kube_node_status_allocatable{resource=\"pods\"}) * 100 > 90",
          "recover_config": {
            "judge_type": 0,
            "recover_exp": ""
          },
          "severity": 2,
          "unit": "",
          "var_config": {
            "child_var_configs": null,
            "param_val": null
          },
          "var_enabled": false
        }
      ]
    },
    "event_relabel_config": null,
    "prom_eval_interval": 15,
    "enable_in_bg": 1,
    "notify_recovered": 1,
    "notify_repeat_step": 60,
    "notify_max_number": 0,
    "recover_duration": 0,
    "callbacks": [],
    "append_tags": [],
    "annotations": {
      "description": "Node {{ $labels.node }} is out of pod capacity\n  VALUE = {{ $value }}\n  LABELS = {{ $labels }}",
      "summary": "Kubernetes Node out of pod capacity (instance {{ $labels.instance }})"
    },
    "uuid": 0,
    "cur_event_count": 0,
    "update_by_nickname": "long",
    "cron_pattern": "@every 60s",
    "notify_rule_ids": [
      1
    ],
    "notify_version": 1
  },
  {
    "cate": "prometheus",
    "datasource_queries": [
      {
        "match_type": 2,
        "op": "in",
        "values": []
      }
    ],
    "name": "KubernetesPersistentvolumeclaimPending",
    "note": "Kubernetes Volume {{ $labels.persistentvolumeclaim }} out of disk space.",
    "prod": "metric",
    "delay": 0,
    "prom_for_duration": 120,
    "rule_config": {
      "inhibit": false,
      "queries": [
        {
          "prom_ql": "kube_persistentvolumeclaim_status_phase{phase=\"Pending\"} == 1",
          "recover_config": {
            "judge_type": 0,
            "recover_exp": ""
          },
          "severity": 2,
          "unit": "",
          "var_config": {
            "child_var_configs": null,
            "param_val": null
          },
          "var_enabled": false
        }
      ]
    },
    "event_relabel_config": null,
    "prom_eval_interval": 15,
    "enable_in_bg": 1,
    "notify_recovered": 1,
    "notify_repeat_step": 60,
    "notify_max_number": 0,
    "recover_duration": 0,
    "callbacks": [],
    "append_tags": [],
    "annotations": {
      "description": "PersistentVolumeClaim {{ $labels.namespace }}/{{ $labels.persistentvolumeclaim }} is pending\n  VALUE = {{ $value }}\n  LABELS = {{ $labels }}",
      "summary": "Kubernetes PersistentVolumeClaim pending ({{ $labels.namespace }}/{{ $labels.persistentvolumeclaim }})"
    },
    "uuid": 0,
    "cur_event_count": 0,
    "update_by_nickname": "long",
    "cron_pattern": "@every 60s",
    "notify_rule_ids": [
      1
    ],
    "notify_version": 1
  },
  {
    "cate": "prometheus",
    "datasource_queries": [
      {
        "match_type": 2,
        "op": "in",
        "values": []
      }
    ],
    "name": "KubernetesPersistentvolumeError",
    "note": "",
    "prod": "metric",
    "delay": 0,
    "prom_for_duration": 60,
    "rule_config": {
      "algo_params": null,
      "inhibit": false,
      "prom_ql": "",
      "queries": [
        {
          "prom_ql": "kube_persistentvolume_status_phase{phase=~\"Failed|Pending\", job=\"kube-state-metrics\"} > 0",
          "recover_config": {
            "judge_type": 0,
            "recover_exp": ""
          },
          "severity": 1,
          "unit": "",
          "var_config": {
            "child_var_configs": null,
            "param_val": null
          },
          "var_enabled": false
        }
      ],
      "severity": 0
    },
    "event_relabel_config": null,
    "prom_eval_interval": 15,
    "enable_in_bg": 1,
    "notify_recovered": 1,
    "notify_repeat_step": 60,
    "notify_max_number": 0,
    "recover_duration": 0,
    "callbacks": [],
    "append_tags": [],
    "annotations": {
      "description": "Persistent volume {{ $labels.persistentvolume }} is in bad state\n  VALUE = {{ $value }}\n  LABELS = {{ $labels }}",
      "summary": "Kubernetes PersistentVolumeClaim pending ({{ $labels.namespace }}/{{ $labels.persistentvolumeclaim }})"
    },
    "uuid": 0,
    "cur_event_count": 0,
    "update_by_nickname": "long",
    "cron_pattern": "@every 60s",
    "notify_rule_ids": [
      1
    ],
    "notify_version": 1
  },
  {
    "cate": "prometheus",
    "datasource_queries": [
      {
        "match_type": 2,
        "op": "in",
        "values": []
      }
    ],
    "name": "KubernetesPodCrashLooping",
    "note": "Pod {{ $labels.namespace }}/{{ $labels.pod }} is crash looping.",
    "prod": "metric",
    "delay": 0,
    "prom_for_duration": 120,
    "rule_config": {
      "inhibit": false,
      "queries": [
        {
          "prom_ql": "increase(kube_pod_container_status_restarts_total[1m]) > 3",
          "recover_config": {
            "judge_type": 0,
            "recover_exp": ""
          },
          "severity": 2,
          "unit": "",
          "var_config": {
            "child_var_configs": null,
            "param_val": null
          },
          "var_enabled": false
        }
      ]
    },
    "event_relabel_config": null,
    "prom_eval_interval": 15,
    "enable_in_bg": 1,
    "notify_recovered": 1,
    "notify_repeat_step": 60,
    "notify_max_number": 0,
    "recover_duration": 0,
    "callbacks": [],
    "append_tags": [],
    "annotations": {},
    "uuid": 0,
    "cur_event_count": 0,
    "update_by_nickname": "long",
    "cron_pattern": "@every 60s",
    "notify_rule_ids": [
      1
    ],
    "notify_version": 1
  },
  {
    "cate": "prometheus",
    "datasource_queries": [
      {
        "match_type": 2,
        "op": "in",
        "values": []
      }
    ],
    "name": "KubernetesPodNotHealthy",
    "note": "Pod {{ $labels.namespace }}/{{ $labels.pod }} has been in a non-running state for longer than 5 minutes.",
    "prod": "metric",
    "delay": 0,
    "prom_for_duration": 300,
    "rule_config": {
      "inhibit": false,
      "queries": [
        {
          "prom_ql": "sum by (namespace, pod) (kube_pod_status_phase{phase=~\"Pending|Unknown|Failed\"}) > 0",
          "recover_config": {
            "judge_type": 0,
            "recover_exp": ""
          },
          "severity": 1,
          "unit": "",
          "var_config": {
            "child_var_configs": null,
            "param_val": null
          },
          "var_enabled": false
        }
      ]
    },
    "event_relabel_config": null,
    "prom_eval_interval": 15,
    "enable_in_bg": 1,
    "notify_recovered": 1,
    "notify_repeat_step": 60,
    "notify_max_number": 0,
    "recover_duration": 0,
    "callbacks": [],
    "append_tags": [],
    "annotations": {},
    "uuid": 0,
    "cur_event_count": 0,
    "update_by_nickname": "long",
    "cron_pattern": "@every 60s",
    "notify_rule_ids": [
      1
    ],
    "notify_version": 1
  },
  {
    "cate": "prometheus",
    "datasource_queries": [
      {
        "match_type": 2,
        "op": "in",
        "values": []
      }
    ],
    "name": "KubernetesReplicasetReplicasMismatch",
    "note": "Kubernetes ReplicasSet mismatch ({{ $labels.namespace }}/{{ $labels.replicaset }}).",
    "prod": "metric",
    "delay": 0,
    "prom_for_duration": 600,
    "rule_config": {
      "inhibit": false,
      "queries": [
        {
          "prom_ql": "kube_replicaset_spec_replicas != kube_replicaset_status_ready_replicas",
          "recover_config": {
            "judge_type": 0,
            "recover_exp": ""
          },
          "severity": 2,
          "unit": "",
          "var_config": {
            "child_var_configs": null,
            "param_val": null
          },
          "var_enabled": false
        }
      ]
    },
    "event_relabel_config": null,
    "prom_eval_interval": 15,
    "enable_in_bg": 1,
    "notify_recovered": 1,
    "notify_repeat_step": 60,
    "notify_max_number": 0,
    "recover_duration": 0,
    "callbacks": [],
    "append_tags": [],
    "annotations": {},
    "uuid": 0,
    "cur_event_count": 0,
    "update_by_nickname": "long",
    "cron_pattern": "@every 60s",
    "notify_rule_ids": [
      1
    ],
    "notify_version": 1
  },
  {
    "cate": "prometheus",
    "datasource_queries": [
      {
        "match_type": 2,
        "op": "in",
        "values": []
      }
    ],
    "name": "KubernetesStatefulsetDown",
    "note": "Kubernetes StatefulSet down ({{ $labels.namespace }}/{{ $labels.statefulset }})",
    "prod": "metric",
    "delay": 0,
    "prom_for_duration": 120,
    "rule_config": {
      "inhibit": false,
      "queries": [
        {
          "prom_ql": "kube_statefulset_replicas != kube_statefulset_status_replicas_ready > 0",
          "recover_config": {
            "judge_type": 0,
            "recover_exp": ""
          },
          "severity": 1,
          "unit": "",
          "var_config": {
            "child_var_configs": null,
            "param_val": null
          },
          "var_enabled": false
        }
      ]
    },
    "event_relabel_config": null,
    "prom_eval_interval": 15,
    "enable_in_bg": 1,
    "notify_recovered": 1,
    "notify_repeat_step": 60,
    "notify_max_number": 0,
    "recover_duration": 0,
    "callbacks": [],
    "append_tags": [],
    "annotations": {
      "description": "StatefulSet {{ $labels.namespace }}/{{ $labels.statefulset }} went down\n  VALUE = {{ $value }}\n  LABELS = {{ $labels }}"
    },
    "uuid": 0,
    "cur_event_count": 0,
    "update_by_nickname": "long",
    "cron_pattern": "@every 60s",
    "notify_rule_ids": [
      1
    ],
    "notify_version": 1
  },
  {
    "cate": "prometheus",
    "datasource_queries": [
      {
        "match_type": 2,
        "op": "in",
        "values": []
      }
    ],
    "name": "KubernetesStatefulsetGenerationMismatch",
    "note": "",
    "prod": "metric",
    "delay": 0,
    "prom_for_duration": 600,
    "rule_config": {
      "algo_params": null,
      "inhibit": false,
      "prom_ql": "",
      "queries": [
        {
          "prom_ql": "kube_statefulset_status_observed_generation != kube_statefulset_metadata_generation",
          "recover_config": {
            "judge_type": 0,
            "recover_exp": ""
          },
          "severity": 1,
          "unit": "",
          "var_config": {
            "child_var_configs": null,
            "param_val": null
          },
          "var_enabled": false
        }
      ],
      "severity": 0
    },
    "event_relabel_config": null,
    "prom_eval_interval": 15,
    "enable_in_bg": 1,
    "notify_recovered": 1,
    "notify_repeat_step": 60,
    "notify_max_number": 0,
    "recover_duration": 0,
    "callbacks": [],
    "append_tags": [],
    "annotations": {
      "description": "StatefulSet {{ $labels.namespace }}/{{ $labels.statefulset }} has failed but has not been rolled back.\n  VALUE = {{ $value }}\n  LABELS = {{ $labels }}",
      "summary": "Kubernetes StatefulSet generation mismatch ({{ $labels.namespace }}/{{ $labels.statefulset }})"
    },
    "uuid": 0,
    "cur_event_count": 0,
    "update_by_nickname": "long",
    "cron_pattern": "@every 60s",
    "notify_rule_ids": [
      1
    ],
    "notify_version": 1
  },
  {
    "cate": "prometheus",
    "datasource_queries": [
      {
        "match_type": 2,
        "op": "in",
        "values": []
      }
    ],
    "name": "KubernetesStatefulsetReplicasMismatch",
    "note": "",
    "prod": "metric",
    "delay": 0,
    "prom_for_duration": 600,
    "rule_config": {
      "algo_params": null,
      "inhibit": false,
      "prom_ql": "",
      "queries": [
        {
          "prom_ql": "kube_statefulset_status_replicas_ready != kube_statefulset_status_replicas",
          "recover_config": {
            "judge_type": 0,
            "recover_exp": ""
          },
          "severity": 2,
          "unit": "",
          "var_config": {
            "child_var_configs": null,
            "param_val": null
          },
          "var_enabled": false
        }
      ],
      "severity": 0
    },
    "event_relabel_config": null,
    "prom_eval_interval": 15,
    "enable_in_bg": 1,
    "notify_recovered": 1,
    "notify_repeat_step": 60,
    "notify_max_number": 0,
    "recover_duration": 0,
    "callbacks": [],
    "append_tags": [],
    "annotations": {
      "description": "StatefulSet does not match the expected number of replicas.\n  VALUE = {{ $value }}\n  LABELS = {{ $labels }}",
      "summary": "Kubernetes StatefulSet replicas mismatch (instance {{ $labels.instance }})"
    },
    "uuid": 0,
    "cur_event_count": 0,
    "update_by_nickname": "long",
    "cron_pattern": "@every 60s",
    "notify_rule_ids": [
      1
    ],
    "notify_version": 1
  },
  {
    "cate": "prometheus",
    "datasource_queries": [
      {
        "match_type": 2,
        "op": "in",
        "values": []
      }
    ],
    "name": "KubernetesStatefulsetUpdateNotRolledOut",
    "note": "",
    "prod": "metric",
    "delay": 0,
    "prom_for_duration": 600,
    "rule_config": {
      "algo_params": null,
      "inhibit": false,
      "prom_ql": "",
      "queries": [
        {
          "prom_ql": "max without (revision) (kube_statefulset_status_current_revision unless kube_statefulset_status_update_revision) * (kube_statefulset_replicas != kube_statefulset_status_replicas_updated)",
          "recover_config": {
            "judge_type": 0,
            "recover_exp": ""
          },
          "severity": 2,
          "unit": "",
          "var_config": {
            "child_var_configs": null,
            "param_val": null
          },
          "var_enabled": false
        }
      ],
      "severity": 0
    },
    "event_relabel_config": null,
    "prom_eval_interval": 15,
    "enable_in_bg": 1,
    "notify_recovered": 1,
    "notify_repeat_step": 60,
    "notify_max_number": 0,
    "recover_duration": 0,
    "callbacks": [],
    "append_tags": [],
    "annotations": {
      "description": "StatefulSet {{ $labels.namespace }}/{{ $labels.statefulset }} update has not been rolled out.\n  VALUE = {{ $value }}\n  LABELS = {{ $labels }}",
      "summary": "Kubernetes StatefulSet update not rolled out ({{ $labels.namespace }}/{{ $labels.statefulset }})"
    },
    "uuid": 0,
    "cur_event_count": 0,
    "update_by_nickname": "long",
    "cron_pattern": "@every 60s",
    "notify_rule_ids": [
      1
    ],
    "notify_version": 1
  },
  {
    "cate": "prometheus",
    "datasource_queries": [
      {
        "match_type": 2,
        "op": "in",
        "values": []
      }
    ],
    "name": "KubernetesVolumeFullInFourDays",
    "note": "Kubernetes Volume {{ $labels.persistentvolumeclaim }} full in four days.",
    "prod": "metric",
    "delay": 0,
    "prom_for_duration": 60,
    "rule_config": {
      "inhibit": false,
      "queries": [
        {
          "prom_ql": "predict_linear(kubelet_volume_stats_available_bytes[6h:5m], 4 * 24 * 3600) < 0",
          "recover_config": {
            "judge_type": 0,
            "recover_exp": ""
          },
          "severity": 1,
          "unit": "",
          "var_config": {
            "child_var_configs": null,
            "param_val": null
          },
          "var_enabled": false
        }
      ]
    },
    "event_relabel_config": null,
    "prom_eval_interval": 15,
    "enable_in_bg": 1,
    "notify_recovered": 1,
    "notify_repeat_step": 60,
    "notify_max_number": 0,
    "recover_duration": 0,
    "callbacks": [],
    "append_tags": [],
    "annotations": {
      "description": "Volume under {{ $labels.namespace }}/{{ $labels.persistentvolumeclaim }} is expected to fill up within four days. Currently {{ $value | humanize }}% is available.\n  VALUE = {{ $value }}\n  LABELS = {{ $labels }}",
      "summary": "Kubernetes Volume full in four days (instance {{ $labels.instance }})"
    },
    "uuid": 0,
    "cur_event_count": 0,
    "update_by_nickname": "long",
    "cron_pattern": "@every 60s",
    "notify_rule_ids": [
      1
    ],
    "notify_version": 1
  },
  {
    "cate": "prometheus",
    "datasource_queries": [
      {
        "match_type": 2,
        "op": "in",
        "values": []
      }
    ],
    "name": "KubernetesVolumeOutOfDiskSpace",
    "note": "Kubernetes Volume {{ $labels.persistentvolumeclaim }} out of disk space.",
    "prod": "metric",
    "delay": 0,
    "prom_for_duration": 120,
    "rule_config": {
      "inhibit": true,
      "queries": [
        {
          "prom_ql": "kubelet_volume_stats_available_bytes / kubelet_volume_stats_capacity_bytes * 100 < 20",
          "recover_config": {
            "judge_type": 0,
            "recover_exp": ""
          },
          "severity": 3,
          "unit": "",
          "var_config": {
            "child_var_configs": null,
            "param_val": null
          },
          "var_enabled": false
        },
        {
          "prom_ql": "kubelet_volume_stats_available_bytes / kubelet_volume_stats_capacity_bytes * 100 < 15",
          "severity": 2
        },
        {
          "prom_ql": "kubelet_volume_stats_available_bytes / kubelet_volume_stats_capacity_bytes * 100 < 10",
          "severity": 1
        }
      ]
    },
    "event_relabel_config": null,
    "prom_eval_interval": 15,
    "enable_in_bg": 1,
    "notify_recovered": 1,
    "notify_repeat_step": 60,
    "notify_max_number": 0,
    "recover_duration": 0,
    "callbacks": [],
    "append_tags": [],
    "annotations": {},
    "uuid": 0,
    "cur_event_count": 0,
    "update_by_nickname": "long",
    "cron_pattern": "@every 60s",
    "notify_rule_ids": [
      1
    ],
    "notify_version": 1
  }
]